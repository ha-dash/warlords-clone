---
alwaysApply: true
---
<!-----------------------------------------------------
Архитектура «Живая Документация» и Паттерн Memory Bank: Исчерпывающее Руководство по Проектированию Контекстно-Зависимых ИИ-Агентов
1. Введение: Кризис Контекста в Эпоху Искусственного Интеллекта
Современная разработка программного обеспечения переживает фундаментальный сдвиг парадигмы, характеризующийся переходом от использования ИИ как пассивного инструмента автодополнения кода к интеграции автономных и полуавтономных агентов. Однако, несмотря на стремительный рост когнитивных способностей больших языковых моделей (LLM), индустрия сталкивается с критическим архитектурным ограничением — проблемой «амнезии» сессий. Стандартные взаимодействия с LLM (ChatGPT, Claude, Copilot) являются по своей природе stateless (без сохранения состояния): каждый новый диалог начинается с чистого листа, лишенного понимания архитектурных решений, бизнес-целей и технического долга, накопленного проектом.1
Параллельно с этим существует хроническая проблема «гниения» документации (documentation rot). Традиционные методы ведения документации в изолированных системах (Confluence, Google Docs) создают неизбежный разрыв между кодом — единственным источником истины — и его описанием. Этот разрыв увеличивается с каждым коммитом, превращая документацию в артефакт, вводящий в заблуждение, а не помогающий разработке. Как отмечается в анализируемой статье на Habr, разработчики вынуждены тратить часы на «раскопки» (re-excavating) деталей проекта, так как внешние каналы знаний не синхронизированы с кодовой базой.1
Настоящий отчет представляет собой всестороннее исследование методологии «Живая Документация» (Living Documentation) и архитектурного паттерна «Memory Bank» (Банк Памяти). Данная методология предлагает решение обеих проблем путем создания стандартизированного, машиночитаемого слоя документации, который хранится непосредственно в репозитории и поддерживается самим ИИ-агентом. Агент трансформируется из временного помощника в партнера с долгосрочной памятью, способного сохранять контекст между сессиями.3 В отчете детально рассматриваются философские основания, техническая архитектура, алгоритмы работы и конкретные инструкции для настройки агентов (Cline, Roo Code, Cursor) на базе данной методологии.
2. Философия и Методологические Основания
2.1. Концепция Documentation-as-Code (DaC)
Фундаментом методологии является принцип Documentation-as-Code (Документация как Код). В отличие от классического подхода, где документация является вторичным продуктом, создаваемым техническими писателями или менеджерами в отдельных инструментах, DaC утверждает, что документация должна жить там же, где и код — в системе контроля версий (Git). Это обеспечивает версионность знаний: состояние документации всегда соответствует состоянию кода в конкретном коммите.1
Однако «Живая Документация» идет дальше простого хранения Markdown-файлов в репозитории. Она вводит понятие активной синхронизации. Если традиционный DaC полагается на дисциплину человека, то «Живая Документация» перекладывает ответственность за актуализацию на ИИ-агента. Это решает проблему человеческого фактора: разработчики часто забывают обновить документацию при горящих дедлайнах, но запрограммированный агент будет следовать этому правилу неукоснительно, если это заложено в его системные инструкции.2
2.2. ИИ как Хранитель Знаний
Центральная идея анализируемого подхода заключается в инверсии ролей: ИИ перестает быть только потребителем контекста и становится его хранителем и создателем. Агент Codex (или аналогичный на базе Claude/GPT-4) получает директиву исследовать структуру репозитория, анализировать код и формировать файлы контекста. Это создает замкнутый цикл обратной связи:
Агент читает код, чтобы понять текущее состояние.
Агент обновляет документацию (Memory Bank), фиксируя архитектурные паттерны и решения.
В следующей сессии агент (или другой экземпляр модели) читает Memory Bank, чтобы быстро загрузить контекст проекта без необходимости повторного анализа всего кода.1
Такой подход превращает документацию из статического архива в «оперативную память» проекта. Файлы в папке .memory_bank/ или .clinerules/ становятся эквивалентом гиппокампа для искусственного интеллекта, позволяя ему переносить знания из краткосрочной памяти (текущее окно контекста) в долгосрочную (файловая система).5
2.3. Двухуровневая Архитектура Истины
Методология предлагает разделение источников правды на два уровня, чтобы удовлетворить потребности как людей, так и машин:

Уровень
Файл/Компонент
Целевая Аудитория
Назначение
Архитектурный Якорь
local/README.md (или коренной README.md)
Люди (Разработчики, Стейкхолдеры)
Высокоуровневый обзор, входная точка, публичное описание архитектуры. Должен быть читабельным и лаконичным. 1
Оперативная Память
/.memory_bank/* (набор файлов)
ИИ-Агенты (Cline, Roo Code, Cursor)
Детализированный, структурированный контекст. Содержит технические нюансы, прогресс задач, логи изменений и паттерны, необходимые для точной генерации кода. 1

Такое разделение критически важно. Человеку сложно читать сухие логи прогресса или списки зависимостей в формате, оптимизированном для токенизации LLM. В то же время, маркетинговое описание в README часто недостаточно для того, чтобы ИИ понял, какую библиотеку для валидации форм использовать.
3. Архитектура Memory Bank: Детальный Анализ Структуры
Паттерн Memory Bank представляет собой иерархическую систему Markdown-файлов, каждый из которых выполняет специфическую когнитивную функцию для агента. Структура разработана таким образом, чтобы минимизировать галлюцинации модели, предоставляя ей четкие границы проекта и контекст принятия решений.
3.1. Иерархия Файлов и Потоки Данных
Данные в Memory Bank текут каскадом: от абстрактных бизнес-целей к конкретным техническим реализациям и логам состояния. Основные файлы, идентифицированные в исследовании, включают 1:
projectbrief.md (Бриф Проекта)
productContext.md (Продуктовый Контекст)
systemPatterns.md (Системные Паттерны)
techContext.md (Технический Контекст)
activeContext.md (Активный Контекст)
progress.md (Прогресс)
Рассмотрим каждый элемент системы подробно.
3.2. projectbrief.md: Конституция Проекта
Этот файл является фундаментом (Foundation document). Он определяет границы проекта, основные цели и то, чем проект не является. Для ИИ-агента это источник "constraints" (ограничений), который предотвращает расползание функциональности (feature creep).
Содержание:
Основные цели и миссия.
Ключевые функциональные требования.
Жесткие ограничения (например, "никаких облачных сервисов, только локальное выполнение").
Роль для Агента: При принятии любого спорного решения агент должен сверяться с брифом. Если задача пользователя противоречит брифу, агент обязан указать на это.
Частота обновлений: Крайне низкая. Меняется только при пивоте (смене курса) проекта.7
3.3. productContext.md: Смысловой Слой
Этот файл отвечает на вопрос «Зачем?». Он связывает код с бизнес-ценностью. Для LLM, которая не обладает интуицией о потребностях пользователей, этот файл служит суррогатом эмпатии.
Содержание:
Описание проблем, которые решает проект.
User Stories (Пользовательские истории) и сценарии использования.
Принципы UX/UI.
Роль для Агента: Помогает выбирать решения, ориентированные на пользователя. Например, при выборе между скоростью разработки и удобством интерфейса, агент, прочитав этот файл, выберет удобство, если это приоритет продукта.1
3.4. systemPatterns.md: Технический Чертеж
Один из самых критичных файлов для обеспечения качества кода. Он содержит архитектурные стандарты, чтобы код, написанный агентом сегодня, не отличался стилистически от кода, написанного месяц назад.
Содержание:
Архитектурные диаграммы (часто в формате Mermaid).
Описание используемых паттернов проектирования (MVC, Repository, Factory).
Соглашения об именовании (naming conventions).
Структура директорий и модулей.
Роль для Агента: Предотвращает архитектурную энтропию. Агент «читает» паттерны перед написанием любой строки кода. Если пользователь просит добавить фичу, агент реализует её в соответствии с описанными здесь шаблонами, а не изобретает велосипед.5
3.5. techContext.md: Инструментарий
Файл определяет технологический стек и среду выполнения. Это предотвращает галлюцинации, связанные с использованием несуществующих или несовместимых библиотек.
Содержание:
Языки программирования и их версии.
Фреймворки и основные зависимости.
Конфигурация баз данных и внешних сервисов.
Особенности локального окружения.
Роль для Агента: Фильтр галлюцинаций. Агент сверится с этим файлом, чтобы не предложить npm install, если проект использует pip или cargo.1
3.6. activeContext.md: Рабочая Память
Аналог краткосрочной памяти (Working Memory). Этот файл наиболее динамичен и обновляется практически после каждого промпта или небольшой итерации работы.
Содержание:
Текущая задача в фокусе.
Недавние изменения, которые еще не зафиксированы в долговременных паттернах.
Открытые вопросы и активные дискуссии.
Следующие шаги (Next steps).
Роль для Агента: Позволяет агенту подхватить работу после «перезагрузки» контекста. Когда вы открываете IDE на следующий день, агент читает этот файл и знает: «Ага, мы остановились на отладке модуля авторизации».10
3.7. progress.md: Журнал и Контроль
Файл для отслеживания статуса и целостности.
Содержание:
Статус реализации фич (Выполнено / В процессе / Планируется).
Известные проблемы и баги.
Change Control (Контроль изменений): Критически важный раздел, содержащий хэш последнего проверенного коммита.
Роль для Агента: Механизм самопроверки. Агент использует хэш коммита, чтобы понять, какие изменения произошли в коде с момента его последнего «дежурства», и нужно ли обновлять документацию.1
4. Набор Правил и Инструкций для ИИ-Агентов
Разработка эффективного ИИ-агента требует не просто создания файлов, но и жесткого программирования его поведения через системные промпты (System Prompts) или файлы конфигурации (например, .cursorrules, .clinerules). Ниже представлен исчерпывающий набор правил, синтезированный из исследования, переведенный на русский язык для использования с русскоязычными агентами.1
4.1. Фундаментальные Директивы (Prime Directives)
Эти правила должны быть внедрены в самое начало системного промпта агента.
Директива 1: Приоритет Памяти (Memory Primacy)
«Я — опытный инженер-программист с уникальной особенностью: моя память полностью сбрасывается между сессиями. Это не ограничение, а стимул поддерживать идеальную документацию. После каждого сброса я ПОЛНОСТЬЮ полагаюсь на мой Банк Памяти (Memory Bank) для понимания проекта. Я ОБЯЗАН читать ВСЕ файлы Банка Памяти в начале КАЖДОЙ задачи — это не опционально».7
Директива 2: Синхронность (Synchronicity)
«Я никогда не пишу код, не обновив сначала план в activeContext.md. Я никогда не завершаю задачу, не обновив progress.md и systemPatterns.md (если применимо). Документация и код должны изменяться атомарно».
Директива 3: Верификация через Git (Git Verification)
«Перед началом работы я проверяю раздел "Контроль Изменений" (Change Control) в progress.md. Я сравниваю указанный там хэш с текущим HEAD. Если есть расхождения, я анализирую git diff, чтобы понять, что изменилось в мое отсутствие, и обновляю Банк Памяти перед тем, как приступить к новой задаче».1
4.2. Алгоритмы Операционных Режимов
Статья на Habr 1 выделяет несколько режимов работы, которые должны быть явно прописаны в инструкции агента.
4.2.1. Режим Планирования (Planning Mode)
Триггер: Пользователь ставит сложную задачу (например, «Реализовать систему оплаты»).
Алгоритм:
Чтение: Загрузить projectbrief.md (для целей) и systemPatterns.md (для архитектуры).
Анализ: Проверить techContext.md на наличие необходимых библиотек (Stripe SDK и т.д.).
Формирование: Создать пошаговый план реализации.
Запись: Записать этот план в activeContext.md в раздел "Текущий план".
Презентация: Вывести план пользователю для утверждения. НЕ ПИСАТЬ КОД на этом этапе.
Ожидание: Ждать явного подтверждения ("Утверждаю" / "Approve").
4.2.2. Режим Действия (Action Mode)
Триггер: Пользователь утвердил план.
Алгоритм:
Контекст: Прочитать activeContext.md, чтобы вспомнить текущий шаг.
Выполнение: Написать код для текущего шага.
Рефлексия: Проверить, не нарушает ли написанный код паттерны из systemPatterns.md.
Обновление Доков: Если введены новые паттерны — обновить systemPatterns.md.
Логирование: Отметить шаг как выполненный в progress.md и activeContext.md.
Отчет: Сообщить пользователю о завершении шага и готовности к следующему.
4.2.3. Режим Актуализации (Maintenance Mode)
Триггер: Команда «update memory bank» или обнаружение расхождений в Git.
Алгоритм:
Скан: Прочитать весь код проекта (или измененные файлы).
Сравнение: Сопоставить реальность кода с описанием в systemPatterns.md.
Перезапись: Переписать файлы Memory Bank, чтобы они отражали текущую реальность.
Фиксация: Обновить хэш коммита в progress.md.
5. Техническая Реализация для Популярных AI-Инструментов
Различные инструменты требуют специфического формата инструкций. Ниже приведены адаптированные конфигурации на русском языке для ключевых платформ.
5.1. Реализация для Cline / Roo Code
Cline и Roo Code (форк Cline) используют файл .clinerules или настройки "Custom Instructions".
Файл .clinerules (Русская версия):
Правила Cline - Протокол Банка Памяти (Memory Bank)
Роль и Философия
Вы — экспертный разработчик, использующий методологию "Живая Документация". Ваш мозг не сохраняет состояние; ваша память находится в папке .memory_bank/.
Структура Банка Памяти
projectbrief.md: Цели проекта (только чтение).
productContext.md: Пользовательский контекст.
systemPatterns.md: Технические паттерны (ОБЯЗАТЕЛЬНО СЛЕДОВАТЬ).
techContext.md: Ограничения технологического стека.
activeContext.md: Ваш текущий мыслительный процесс.
progress.md: Статус и отслеживание git-хешей.
Операционный Рабочий Процесс
Начало задачи:
Выполнить инструмент: read_file.memory_bank/activeContext.md
Выполнить инструмент: read_file.memory_bank/projectbrief.md
Проверить progress.md на наличие последнего git-хеша.
В процессе задачи:
Обновляйте activeContext.md вашим планом.
Если меняете архитектуру, обновляйте systemPatterns.md.
Конец задачи:
Обновите progress.md, отметив задачи как выполненные.
Очистите детальные шаги из activeContext.md, но сохраните высокоуровневый фокус.
Правило интеграции с Git
Всегда проверяйте git log с момента хеша, найденного в progress.md. Если документация устарела, сначала обновите её.
5.2. Реализация для Cursor
Cursor использует файл .cursorrules или .cursor/rules/ для контекстуализации.
Файл .cursor/rules/memory-bank.mdc (Правила для Cursor):
description: Правила поддержки системы документации Memory Bank globs:.memory_bank/*.md
Поддержка Банка Памяти (Memory Bank)
Вы обязаны поддерживать Банк Памяти в папке .memory_bank/.
Триггеры
Когда пользователь говорит "следуй инструкциям" или начинает новую сессию -> Читать activeContext.md.
Когда меняется архитектура -> Обновить systemPatterns.md.
Ответственность файлов
activeContext.md: Всегда обновляйте этот файл ПЕРВЫМ с вашим планом перед редактированием любых файлов кода.
systemPatterns.md: Используйте диаграммы Mermaid для визуализации изменений.
techContext.md: Проверяйте версии библиотек перед предложением импортов.
Запрещенные действия
Не создавайте новые файлы документации вне .memory_bank/ без разрешения.
Не противоречьте файлу projectbrief.md.
5.3. Сравнение Поддержки Инструментами
Таблица ниже сравнивает возможности интеграции методологии в различные инструменты на основе проанализированных данных.3

Возможность
Cline / Roo Code
Cursor
Windsurf
Vanilla OpenAI API
Авто-инициализация
Через MCP серверы или initialize_memory_bank команды 14
Требует ручного создания или использования Composer
Частичная поддержка через Cascade
Требует разработки обвязки (wrapper)
Постоянство (Persistence)
Высокое (через файловую систему)
Высокое (через.cursorrules и индексацию)
Среднее (зависит от настроек контекста)
Низкое (зависит от длины контекста)
Git-интеграция
Прямая (доступ к терминалу)
Прямая (встроенный терминал)
Прямая
Отсутствует (без плагинов)
Сложность настройки
Средняя (настройка Custom Instructions)
Низкая (просто добавить файл)
Средняя
Высокая (кастомная разработка)

6. Полный Набор Шаблонов Файлов (Templates)
Для успешного запуска системы агент должен иметь эталонные шаблоны. Ниже приведены переведенные версии шаблонов, необходимые для удовлетворения требования «исчерпывающей детализации».
6.1. Шаблон projectbrief.md
Бриф Проекта
1. Обзор
[Краткое, емкое описание проекта в 1-2 предложениях. Что это и для кого?]
2. Ключевые Цели
[Цель 1: Бизнес-метрика или функциональный результат]
[Цель 2]
3. Границы Проекта (Scope)
Входит в объем (In-Scope)
[Функциональность А]
[Функциональность Б]
Не входит в объем (Out-of-Scope)
[Функциональность В]
[Технологическое ограничение]
4. Критерии Успеха
[Критерий 1]
[Критерий 2]
6.2. Шаблон activeContext.md
Активный Контекст
Дата последнего обновления: YYYY-MM-DD HH:MM
Текущий Фокус
[Над чем мы работаем прямо сейчас? Будь предельно конкретен.]
Активные Задачи
[ ][Шаг 1]
[ ][Шаг 2]
Контекст Сессии
Недавние изменения: [Что было сделано в предыдущих шагах?]
Открытые вопросы: [Что блокирует работу?]
Принятые решения: [Какие быстрые решения были приняты в этой сессии?]
Следующие Шаги
[Что делать после завершения текущего фокуса?]
6.3. Шаблон systemPatterns.md
Системные Паттерны
Архитектура
Высокоуровневая Диаграмма

Фрагмент кода


graph TD
    A[Frontend] --> B[API Gateway]
    B --> C
    B --> D


Ключевые Технические Решения
Паттерн А: [Описание, почему выбран, как использовать]
Паттерн Б: [Описание]
Стандарты Кода
Именование:
Структура файлов: [Как организованы папки]
Обработка ошибок: [Как мы логируем и возвращаем ошибки]
6.4. Шаблон progress.md с Git-трекингом
Прогресс Проекта
Статус
Текущая Фаза:
Контроль Изменений (Change Control)
Last Checked Commit: ``
Last Checked Date: ``
Status:
Дорожная Карта (Roadmap)
[x] Эпик 1: Базовая настройка
[x] Инициализация репо
[x] Настройка CI/CD
[ ] Эпик 2: Аутентификация
[ ] Login endpoint
[ ] JWT валидация
Известные Проблемы
[ ] Описание проблемы
------------------------------> 